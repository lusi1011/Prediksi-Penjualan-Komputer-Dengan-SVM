# -*- coding: utf-8 -*-
"""streamlit

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1shO92uUQrrLOIZ5jRJSjmyTY4Ah8rROx
"""

import streamlit as st
import pandas as pd
import numpy as np
import altair as alt
from sklearn.model_selection import train_test_split, RandomizedSearchCV
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.feature_selection import SelectKBest, f_regression
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error

# Konfigurasi Halaman
st.set_page_config(layout="wide", page_title="SVR Product Sales Analysis")
st.title("Analisis SVR pada Penjualan Produk (Agregat)")
st.caption("Menganalisis dan memprediksi target (misal: Total Sales) berdasarkan fitur (misal: Total Quantity) pada tingkat produk.")

# --- 1. Fungsi Pembantu dan Pemrosesan Data ---

@st.cache_data
def mean_absolute_percentage_error(y_true, y_pred):
    """Menghitung MAPE, aman dari pembagian nol atau nilai sangat kecil."""
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    
    # Gunakan epsilon kecil untuk menghindari pembagian dengan nol
    epsilon = 1e-6
    mask = np.abs(y_true) > epsilon
    
    # Hitung hanya pada data yang valid
    y_true_filtered = y_true[mask]
    y_pred_filtered = y_pred[mask]
    
    if len(y_true_filtered) == 0:
        return 0.0 # Jika tidak ada data valid, error 0
        
    return np.mean(np.abs((y_true_filtered - y_pred_filtered) / y_true_filtered)) * 100

@st.cache_data
def load_and_process_data():
    """Memuat, memfilter, MENGAGREGASI per produk, dan membersihkan data."""
    try:
        df = pd.read_csv('SuperStore_Sales_Dataset.csv')
        df = df.rename(columns={'Row ID+O6G3A1:R6': 'Row ID'})
    except FileNotFoundError:
        st.error("File 'SuperStore_Sales_Dataset.csv' tidak ditemukan. Analisis dibatalkan.")
        return None, None
    except Exception as e:
        st.error(f"Error saat membaca CSV: {e}")
        return None, None
        
    # Filter data (Technology, non-Phones)
    df_tech = df[df['Category'] == 'Technology']
    df_com = df_tech[df_tech['Sub-Category'] != 'Phones']
    
    # --- PERUBAHAN KUNCI: AGREGRASI BERDASARKAN NAMA PRODUK ---
    # Kita tidak bisa memprediksi 'Product Name', jadi kita kelompokkan berdasarkan itu.
    if 'Product Name' not in df_com.columns:
        st.error("Kolom 'Product Name' tidak ditemukan. Agregasi dibatalkan.")
        return None, df_com

    # Ambil fitur yang relevan SEBELUM agregasi
    df_relevant = df_com[['Product Name', 'Sales', 'Profit', 'Quantity']].dropna().copy()

    # Agregasi data: Setiap baris adalah satu produk unik
    df_agg = df_relevant.groupby('Product Name').agg(
        Sales=('Sales', 'sum'),
        Profit=('Profit', 'sum'),
        Quantity=('Quantity', 'sum')
    ).reset_index()

    # Simpan nama produk untuk referensi
    product_names = df_agg[['Product Name']].copy()
    
    # Filter data ekstrem (filter ini sekarang berlaku untuk TOTAL per produk)
    df_clean = df_agg[
        (df_agg['Sales'] < 3000) & (df_agg['Sales'] > 0) &
        (df_agg['Profit'] > -500) & (df_agg['Profit'] < 800)
    ]
    
    # Sampling yang Aman
    n_samples = 50
    if len(df_clean) == 0:
        st.warning("Tidak ada data produk yang tersisa setelah filter agregat.")
        return None, df_com
        
    if len(df_clean) < n_samples:
        n_samples = len(df_clean)
    
    # df_clean sekarang berisi data agregat yang disample
    # df_com adalah data mentah yang difilter (untuk 'Lihat Data Mentah')
    return df_clean.sample(n=n_samples, random_state=42), df_com, df_agg.sort_values(by='Sales', ascending=False)


@st.cache_data
def run_feature_selection(df_clean, target_column):
    """Menjalankan SelectKBest untuk menemukan fitur terbaik."""
    if df_clean is None or len(df_clean) < 10:
        return pd.DataFrame()

    # PERBAIKAN: Fitur sekarang adalah semua kolom KECUALI target
    # Kita HAPUS 'Product Name' dari sini karena bukan fitur numerik
    all_columns = ['Sales', 'Profit', 'Quantity']
    features = [col for col in all_columns if col != target_column]
    target = target_column
    
    # Periksa jika tidak ada fitur tersisa (misal: jika 'all_columns' hanya punya 1 item)
    if not features:
        st.warning(f"Tidak ada fitur yang tersisa untuk memprediksi {target}.")
        return pd.DataFrame()
        
    X = df_clean[features]
    Y = df_clean[target]
    
    # Scaling diperlukan agar F-scores dapat dibandingkan
    scaler = MinMaxScaler()
    X_scaled = scaler.fit_transform(X)
    
    # Gunakan f_regression untuk regresi, k='all' untuk mendapatkan skor semua fitur
    selector = SelectKBest(f_regression, k='all')
    selector.fit(X_scaled, Y)
    
    scores_df = pd.DataFrame({
        'Fitur': features,
        'F-Score': selector.scores_
    }).sort_values(by='F-Score', ascending=False)
    
    return scores_df

@st.cache_data(show_spinner="Menjalankan SVR untuk semua kernel...")
def run_all_svr_analysis(df_clean, selected_feature, selected_target):
    """Menjalankan SVR untuk semua kernel pada fitur dan target yang dipilih."""
    if df_clean is None or len(df_clean) < 10:
        return pd.DataFrame(), pd.DataFrame()

    # X dan Y sekarang sepenuhnya dinamis
    X = df_clean[selected_feature].values.reshape(-1, 1)
    Y = df_clean[selected_target].values.reshape(-1, 1)

    test_split_size = 0.2
    if len(df_clean) * test_split_size < 1:
        test_split_size = 0.1 
            
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=test_split_size, random_state=42)
    
    if len(X_test) == 0:
        return pd.DataFrame(), pd.DataFrame()

    scaler_X = StandardScaler()
    scaler_Y = StandardScaler()
    X_train_scaled = scaler_X.fit_transform(X_train)
    X_test_scaled = scaler_X.transform(X_test)
    Y_train_scaled = scaler_Y.fit_transform(Y_train).ravel()

    kernels = ['linear', 'poly', 'rbf', 'sigmoid']
    model_results = []
    
    X_range_scaled = np.linspace(X_train_scaled.min(), X_train_scaled.max(), 50).reshape(-1, 1)
    plot_data_list = []
    
    # DataFrame plot menggunakan nama fitur dan target yang dinamis
    n_plot_samples = 10
    df_test_actual = pd.DataFrame({selected_feature: X_test.ravel(), selected_target: Y_test.ravel()})
    if len(df_test_actual) > n_plot_samples:
        df_test_actual = df_test_actual.sample(n=n_plot_samples, random_state=42)
    df_test_actual['Type'] = 'Actual'
    
    for kernel in kernels:
        # Konfigurasi parameter default
        if kernel == 'linear': svr = SVR(kernel=kernel, C=10)
        elif kernel == 'poly': svr = SVR(kernel=kernel, C=10, degree=1, gamma=0.1)
        elif kernel == 'rbf': svr = SVR(kernel=kernel, C=10, gamma=0.1)
        elif kernel == 'sigmoid': svr = SVR(kernel=kernel, C=10, gamma=0.1, coef0=0)
            
        # Model harus di-fit pada data training
        svr.fit(X_train_scaled, Y_train_scaled)
        
        # Evaluasi Metrik pada Test Set
        Y_pred_test_scaled = svr.predict(X_test_scaled)
        Y_pred_test = scaler_Y.inverse_transform(Y_pred_test_scaled.reshape(-1, 1))
        
        mse = mean_squared_error(Y_test, Y_pred_test)
        rmse = np.sqrt(mse)
        mae = mean_absolute_error(Y_test, Y_pred_test)
        r2 = r2_score(Y_test, Y_pred_test)
        mape = mean_absolute_percentage_error(Y_test, Y_pred_test)
        model_results.append({
            'Kernel': kernel, 
            'MSE': mse, 
            'RMSE': rmse, # Baru
            'MAE': mae,  # Baru
            'R2': r2, 
            'MAPE': mape
        })

        # Prediksi untuk plotting hyperplane (GARIS)
        Y_pred_range_scaled = svr.predict(X_range_scaled)
        Y_pred_range = scaler_Y.inverse_transform(Y_pred_range_scaled.reshape(-1, 1))

        # DataFrame prediksi menggunakan nama fitur dan target yang dinamis
        df_pred = pd.DataFrame({
            selected_feature: scaler_X.inverse_transform(X_range_scaled).ravel(),
            selected_target: Y_pred_range.ravel(),
            'Kernel': kernel,
            'Type': 'Prediction'
        })
        
        df_actual_temp = df_test_actual.copy()
        df_actual_temp['Kernel'] = kernel
        
        plot_data_list.append(df_actual_temp)
        plot_data_list.append(df_pred)

    df_metrics = pd.DataFrame(model_results)
    df_plot_final = pd.concat(plot_data_list, ignore_index=True)

    return df_metrics, df_plot_final

def create_svr_chart(df_data, kernel_name, title, selected_feature, x_label, selected_target, y_label):
    """Membuat chart Altair individual, kini dengan sumbu X dan Y yang dinamis."""
    df_kernel = df_data[df_data['Kernel'] == kernel_name].copy()
    if df_kernel.empty:
        return None 

    base = alt.Chart(df_kernel).encode(
        # Sumbu X dan Y serta tooltip sekarang dinamis
        x=alt.X(selected_feature, title=x_label, scale=alt.Scale(zero=False)),
        y=alt.Y(selected_target, title=y_label, scale=alt.Scale(zero=False)),
        tooltip=[selected_feature, selected_target]
    )
    
    scatter = base.transform_filter(
        alt.FieldEqualPredicate(field='Type', equal='Actual')
    ).mark_point(opacity=0.6, size=50, color='gray', filled=True)
    
    line = base.transform_filter(
        alt.FieldEqualPredicate(field='Type', equal='Prediction')
    ).mark_line(size=3, color='#FF4B4B')
    
    chart = (scatter + line).properties(title=title).interactive()
    return chart

@st.cache_data(show_spinner="Menghitung SVR Kustom...")
def run_custom_svr(df_clean, selected_feature, selected_target, kernel, C, gamma, degree=3, coef0=0.0):
    """Menjalankan SVR kustom pada fitur dan target yang dipilih."""
    # X dan Y sekarang sepenuhnya dinamis
    X = df_clean[selected_feature].values.reshape(-1, 1)
    Y = df_clean[selected_target].values.reshape(-1, 1)

    scaler_X = StandardScaler()
    scaler_Y = StandardScaler()
    X_scaled = scaler_X.fit_transform(X)
    Y_scaled = scaler_Y.fit_transform(Y).ravel()
    
    # Konfigurasi SVR
    if kernel == 'poly':
        svr = SVR(kernel=kernel, C=C, degree=degree, gamma=gamma)
    elif kernel == 'sigmoid':
        svr = SVR(kernel=kernel, C=C, gamma=gamma, coef0=coef0)
    else:
        svr = SVR(kernel=kernel, C=C, gamma=gamma)
        
    svr.fit(X_scaled, Y_scaled)
    
    X_range_scaled = np.linspace(X_scaled.min(), X_scaled.max(), 100).reshape(-1, 1)
    Y_pred_range_scaled = svr.predict(X_range_scaled)
    Y_pred_range = scaler_Y.inverse_transform(Y_pred_range_scaled.reshape(-1, 1))

    # DataFrame plot menggunakan nama fitur dan target yang dinamis
    df_pred_custom = pd.DataFrame({
        selected_feature: scaler_X.inverse_transform(X_range_scaled).ravel(),
        selected_target: Y_pred_range.ravel(),
        'Kernel': kernel,
        'Type': 'Prediction'
    })
    
    df_actual_custom = pd.DataFrame({selected_feature: X.ravel(), selected_target: Y.ravel()})
    df_actual_custom['Kernel'] = kernel
    df_actual_custom['Type'] = 'Actual'
    
    df_plot_custom = pd.concat([df_actual_custom, df_pred_custom], ignore_index=True)
    return df_plot_custom

@st.cache_data(show_spinner="Mencari parameter RBF terbaik (RandomizedSearch)...")
def run_parameter_tuning(df_clean, selected_feature, selected_target):
    """Menjalankan RandomizedSearchCV untuk menemukan parameter RBF terbaik."""
    X = df_clean[selected_feature].values.reshape(-1, 1)
    Y = df_clean[selected_target].values.reshape(-1, 1)

    scaler_X = StandardScaler()
    scaler_Y = StandardScaler()
    X_scaled = scaler_X.fit_transform(X)
    Y_scaled = scaler_Y.fit_transform(Y).ravel()
    
    # Tentukan rentang parameter untuk dicari
    param_dist = {
        'C': np.logspace(-1, 3, 20), # 0.1 s/d 1000
        'gamma': np.logspace(-3, 1, 20), # 0.001 s/d 10
    }
    
    # Gunakan SVR dengan kernel RBF
    svr = SVR(kernel='rbf')
    
    # n_iter=15: Coba 15 kombinasi acak
    # cv=3: 3-fold cross-validation
    random_search = RandomizedSearchCV(
        svr, 
        param_distributions=param_dist, 
        n_iter=15, 
        cv=3, 
        scoring='r2', # Fokus pada R2 Score terbaik
        n_jobs=-1, # Gunakan semua core CPU
        random_state=42
    )
    
    random_search.fit(X_scaled, Y_scaled)
    
    return random_search.best_params_, random_search.best_score_

# --- 2. Main Streamlit Execution ---
# --- PERUBAHAN: Fungsi load data sekarang mengembalikan 3 nilai ---
df_clean, df_raw_filtered, df_product_ranking = load_and_process_data()

# Tampilkan Data Mentah
if df_raw_filtered is not None:
    with st.expander("Lihat Data Mentah (SEBELUM Agregasi, Kategori: Technology, Bukan Phones)"):
        st.write(df_raw_filtered)

# Hanya jalankan jika data berhasil di-load dan diproses
if df_clean is not None and len(df_clean) >= 10:
    
    # --- PERUBAHAN: Label ini sekarang merujuk ke TOTAL per produk ---
    all_columns = ['Sales', 'Profit', 'Quantity']
    feature_labels = {
        'Sales': 'Total Penjualan (Sales)',
        'Profit': 'Total Keuntungan (Profit)',
        'Quantity': 'Total Jumlah (Quantity)'
    }
    
    # --- Bagian 1: Konfigurasi Model Interaktif ---
    st.header("1. Konfigurasi Analisis SVR (pada Data Agregat Produk)")
    st.markdown("Pilih **Target (Sumbu Y)** dan **Fitur (Sumbu X)** yang ingin Anda analisis. Ingat, data ini adalah **Total** per produk unik.")
    
    # Pilihan Target (Y-Axis)
    selected_target = st.selectbox(
        "Pilih Target (Sumbu Y) untuk Diprediksi:",
        all_columns,
        index=0, # Default: 'Total Sales'
        format_func=lambda x: feature_labels[x]
    )
    selected_target_label = feature_labels[selected_target]

    # Fitur yang tersedia adalah semua kolom KECUALI target yang dipilih
    available_features = [f for f in all_columns if f != selected_target]
    
    # --- BAGIAN BARU: Menampilkan Peringkat Produk ---
    st.header(f"Peringkat Produk Terlaris (Berdasarkan {selected_target_label})")
    st.markdown("Ini adalah jawaban langsung untuk 'produk terlaris'. Ini adalah analisis deskriptif, **bukan** hasil SVR.")
    with st.expander("Lihat Daftar Peringkat Produk (Top 20)"):
        if df_product_ranking is not None:
            # Urutkan berdasarkan target yang dipilih pengguna
            st.dataframe(
                df_product_ranking.sort_values(by=selected_target, ascending=False).head(20), 
                use_container_width=True
            )
        else:
            st.warning("Gagal memuat peringkat produk.")
            
    st.markdown("---")


    # --- Bagian 2: Analisis Seleksi Fitur ---
    st.header(f"2. Analisis Fitur (Target: {selected_target_label})")
    st.markdown(f"Fitur mana yang memiliki hubungan statistik terkuat dengan **{selected_target_label}**? (Data Agregat)")
    
    # Jalankan seleksi fitur pada target yang dipilih
    feature_scores_df = run_feature_selection(df_clean, selected_target)
    
    if not feature_scores_df.empty:
        st.dataframe(feature_scores_df, use_container_width=True)
        st.caption("Metode: `SelectKBest` dengan `f_regression`. F-Score yang lebih tinggi menunjukkan fitur yang lebih baik untuk prediksi.")
        # Tentukan fitur terbaik secara default dari daftar yang tersedia
        default_feature = feature_scores_df.iloc[0]['Fitur']
        default_index = available_features.index(default_feature)
    else:
        st.warning("Gagal menjalankan analisis fitur.")
        default_index = 0 # Fallback
    
    # Pilihan Fitur (X-Axis)
    selected_feature = st.selectbox(
        "Pilih Fitur (Sumbu X) untuk Regresi:",
        available_features,
        index=default_index,
        format_func=lambda x: feature_labels[x] # Tampilkan label yang mudah dibaca
    )
    selected_feature_label = feature_labels[selected_feature]

    # --- Bagian 3: Menampilkan Metrik Evaluasi ---
    st.header(f"3. Perbandingan Metrik (Prediksi {selected_target_label} berdasarkan {selected_feature_label})")
    
    # Kirim 'selected_feature' DAN 'selected_target' ke fungsi analisis
    df_metrics, df_plot_final = run_all_svr_analysis(df_clean, selected_feature, selected_target)
    
    if not df_metrics.empty:
        df_metrics_display = df_metrics.copy()
        df_metrics_display['MSE'] = df_metrics_display['MSE'].round(2)
        # Tampilkan metrik baru
        df_metrics_display['RMSE'] = df_metrics_display['RMSE'].round(2)
        df_metrics_display['MAE'] = df_metrics_display['MAE'].round(2)
        df_metrics_display['R2'] = df_metrics_display['R2'].round(4)
        df_metrics_display['MAPE'] = df_metrics_display['MAPE'].round(2).astype(str) + ' %'
        
        # Urutkan berdasarkan R2, tapi tampilkan semua metrik baru
        st.dataframe(df_metrics_display.sort_values(by='R2', ascending=False), use_container_width=True)
    else:
        st.warning("Gagal menghitung metrik model.")

    # --- Bagian 4: Visualisasi Hyperplane (Semua Kernel Default) ---
    st.header("4. Visualisasi Hyperplane Regresi (Default Parameters)")
    if not df_plot_final.empty:
        col1, col2 = st.columns(2)
        kernels = ['linear', 'poly', 'rbf', 'sigmoid']
        titles = ['Linear', 'Polynomial', 'RBF', 'Sigmoid']
        
        for i, (kernel, title) in enumerate(zip(kernels, titles)):
            # Kirim 'selected_feature' dan 'selected_target' ke fungsi plot
            chart = create_svr_chart(
                df_plot_final, 
                kernel, 
                f'SVR Kernel {title}', 
                selected_feature, 
                selected_feature_label,
                selected_target,
                selected_target_label
            )
            if chart:
                target_col = col1 if i % 2 == 0 else col2
                with target_col:
                    st.subheader(f"Kernel: {title}")
                    st.altair_chart(chart, use_container_width=True)

    # --- Bagian 5: Otomatisasi Tuning (BARU) ---
    st.header("5. Otomatisasi Tuning Parameter (RBF Kernel)")
    st.markdown("Mencari parameter `C` dan `Gamma` terbaik untuk Kernel RBF menggunakan `RandomizedSearchCV`.")
    
    with st.spinner("Sedang menjalankan pencarian parameter... Ini mungkin perlu waktu sejenak."):
        best_params, best_score = run_parameter_tuning(df_clean, selected_feature, selected_target)
    
    st.success(f"Pencarian Selesai! Skor R2 terbaik (cross-validation): **{best_score:.4f}**")
    st.write("Parameter terbaik yang ditemukan:")
    st.json(best_params)
    st.info("Coba masukkan parameter terbaik ini (atau yang mendekatinya) di panel 'Tuning Parameter SVR' di sidebar (Bagian 6 di bawah) untuk melihat visualisasinya.")


    # --- Bagian 6 (sebelumnya 5): Interaktivitas: Custom Kernel ---
    st.header("6. Interaktif: Uji Coba Kernel dan Tuning Parameter")
    st.sidebar.header("Tuning Parameter SVR")
    
    selected_kernel = st.sidebar.selectbox("Pilih Kernel", ['rbf', 'linear', 'poly', 'sigmoid'], index=0)
    c_value = st.sidebar.slider("Pilih nilai C (Regularisasi)", 0.1, 100.0, 50.0)
    
    gamma_value = 'auto'
    if selected_kernel in ['rbf', 'poly', 'sigmoid']:
        gamma_value = st.sidebar.slider("Pilih nilai Gamma", 0.001, 10.0, 0.1)

    degree_value = 3
    coef0_value = 0.0
    if selected_kernel == 'poly':
        degree_value = st.sidebar.slider("Pilih Degree (untuk Poly)", 1, 5, 2)
    if selected_kernel == 'sigmoid':
        coef0_value = st.sidebar.slider("Pilih Coef0 (untuk Sigmoid)", -10.0, 10.0, 0.0)

    # Kirim 'selected_feature' DAN 'selected_target' ke fungsi kustom
    df_plot_custom = run_custom_svr(
        df_clean, selected_feature, selected_target, selected_kernel, c_value, 
        gamma_value, degree_value, coef0_value
    )
    
    custom_chart = create_svr_chart(
        df_plot_custom, 
        selected_kernel, 
        f'SVR Kustom: Kernel {selected_kernel.capitalize()}, C={c_value:.1f}', 
        selected_feature, 
        selected_feature_label,
        selected_target,
        selected_target_label
    )
    if custom_chart: st.altair_chart(custom_chart, use_container_width=True)

    st.markdown("---")
else:
    if df_clean is not None:
        st.error(f"Data tersisa ({len(df_clean)} baris) terlalu sedikit untuk analisis SVR (minimal 10 baris diperlukan). Coba sesuaikan filter di `load_and_process_data`.")
