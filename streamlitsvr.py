# -*- coding: utf-8 -*-
"""streamlitsvr.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zDg5UMjK1af5nQYwWkTQI_9i7OItWawr
"""

import streamlit as st
import pandas as pd
import numpy as np
import altair as alt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, r2_score

st.set_page_config(layout="wide")
st.title("ðŸš€ Analisis Support Vector Regression (SVR) pada Data Penjualan")

# --- 1. Fungsi Pembantu dan Pemrosesan Data ---

# Fungsi kustom untuk menghitung MAPE
def mean_absolute_percentage_error(y_true, y_pred):
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    # Hindari pembagian dengan nol jika y_true ada yang 0
    y_true[y_true == 0] = 1e-6 
    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

# Cache data agar proses ini hanya berjalan sekali
@st.cache_data
def load_and_process_data():
    # Pastikan file CSV ada di root directory repository Streamlit Cloud Anda
    try:
        df = pd.read_csv("SuperStore_Sales_Dataset.csv", sep=",", na_values="#N/A")
    except FileNotFoundError:
        st.error("File 'SuperStore_Sales_Dataset.csv' tidak ditemukan. Pastikan file tersebut ada di repository Anda.")
        return None
        
    df_clean = df[['Sales', 'Profit', 'Quantity']].dropna().copy()
    
    # Filter data ekstrem (sama seperti sebelumnya)
    df_clean = df_clean[(df_clean['Sales'] < 3000) & 
                        (df_clean['Sales'] > 0) & 
                        (df_clean['Profit'] > -500) & 
                        (df_clean['Profit'] < 800)]
    
    # Mengambil subset untuk efisiensi komputasi SVR
    # 3000 sample sudah cukup banyak, 2000 mungkin lebih cepat di Streamlit Cloud
    return df_clean.sample(n=2000, random_state=42) 

@st.cache_data
def run_svr_analysis(df_clean):
    if df_clean is None:
        return pd.DataFrame(), pd.DataFrame()

    X = df_clean['Profit'].values.reshape(-1, 1)
    Y = df_clean['Sales'].values.reshape(-1, 1)

    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.3, random_state=42)
    
    scaler_X = StandardScaler()
    scaler_Y = StandardScaler()
    X_train_scaled = scaler_X.fit_transform(X_train)
    X_test_scaled = scaler_X.transform(X_test)
    Y_train_scaled = scaler_Y.fit_transform(Y_train).ravel()

    # <<< PERUBAHAN 1: Menambahkan kernel 'linear' sesuai permintaan >>>
    kernels = ['linear', 'poly', 'rbf', 'sigmoid'] 
    model_results = []
    
    # OPTIMASI 1: Kurangi titik data untuk plot hyperplane
    # 50 titik untuk garis hyperplane
    X_range_scaled = np.linspace(X_train_scaled.min(), X_train_scaled.max(), 50).reshape(-1, 1)
    
    # Siapkan DataFrame untuk hasil plot gabungan (data aktual dan prediksi)
    plot_data_list = []

    # Ambil 50 data acak dari test set untuk SCATTER PLOT
    df_test_sample = pd.DataFrame({'Profit': X_test.ravel(), 'Sales': Y_test.ravel()})
    df_test_sample = df_test_sample.sample(n=50, random_state=42).copy() # HANYA 50 TITIK!
    df_test_sample['Type'] = 'Actual'

    for kernel in kernels:
        # Gunakan parameter yang lebih ringan untuk performa lebih baik
        if kernel == 'poly':
            # Derajat 3 (default) bisa jadi lambat, mungkin 2 lebih baik
            svr = SVR(kernel=kernel, C=50, degree=2, gamma='auto') 
        else:
            svr = SVR(kernel=kernel, C=50, gamma='auto') 
            
        svr.fit(X_train_scaled, Y_train_scaled)
        
        # Evaluasi Metrik
        Y_pred_test_scaled = svr.predict(X_test_scaled)
        Y_pred_test = scaler_Y.inverse_transform(Y_pred_test_scaled.reshape(-1, 1))
        mse = mean_squared_error(Y_test, Y_pred_test)
        r2 = r2_score(Y_test, Y_pred_test)
        mape = mean_absolute_percentage_error(Y_test, Y_pred_test)
        model_results.append({'Kernel': kernel, 'MSE': mse, 'R2': r2, 'MAPE': mape})

        # Prediksi untuk plotting hyperplane (GARIS)
        Y_pred_range_scaled = svr.predict(X_range_scaled)
        Y_pred_range = scaler_Y.inverse_transform(Y_pred_range_scaled.reshape(-1, 1))

        # OPTIMASI 2: Buat DataFrame Prediksi
        df_pred = pd.DataFrame({
            'Profit': scaler_X.inverse_transform(X_range_scaled).ravel(),
            'Sales': Y_pred_range.ravel(),
            'Kernel': kernel,
            'Type': 'Prediction'
        })
        
        # Gabungkan data aktual (sample) dan prediksi (garis)
        df_actual_temp = df_test_sample.copy()
        df_actual_temp['Kernel'] = kernel
        
        plot_data_list.append(df_actual_temp)
        plot_data_list.append(df_pred)

    df_metrics = pd.DataFrame(model_results)
    df_plot_final = pd.concat(plot_data_list, ignore_index=True)

    return df_metrics, df_plot_final

# --- 2. Main Streamlit Execution ---
df_clean = load_and_process_data()

# Hanya jalankan jika data berhasil di-load
if df_clean is not None:
    df_metrics, df_plot_final = run_svr_analysis(df_clean)

    # --- 3. Menampilkan Metrik Evaluasi ---
    st.header("1. Metrik Evaluasi Model")

    df_metrics['MSE'] = df_metrics['MSE'].round(2)
    df_metrics['R2'] = df_metrics['R2'].round(4)
    df_metrics['MAPE'] = df_metrics['MAPE'].round(2).astype(str) + ' %'

    st.table(df_metrics.sort_values(by='R2', ascending=False))

    # --- 4. Menampilkan Grafik Hyperplane (Altair) ---
    # <<< PERUBAHAN 2: Memisahkan chart, tidak lagi menggunakan facet >>>
    
    st.header("2. Visualisasi Hyperplane Regresi (Terpisah)")

    # Fungsi helper untuk membuat chart individual
    def create_svr_chart(df_data, kernel_name, title):
        """
        Membuat chart Altair (scatter + line) untuk kernel SVR tertentu.
        """
        # Filter data hanya untuk kernel yang diinginkan
        df_kernel = df_data[df_data['Kernel'] == kernel_name].copy()

        base = alt.Chart(df_kernel).encode(
            x=alt.X('Profit', title='Keuntungan (Profit)', scale=alt.Scale(zero=False)),
            y=alt.Y('Sales', title='Penjualan (Sales)', scale=alt.Scale(zero=False)),
            tooltip=['Profit', 'Sales']
        )

        # Scatter plot: Hanya tampilkan titik untuk Type == 'Actual'
        scatter = base.transform_filter(
            alt.FieldEqualPredicate(field='Type', equal='Actual')
        ).mark_point(opacity=0.6, size=30, color='gray', filled=True)

        # Line chart: Hanya tampilkan garis untuk Type == 'Prediction'
        line = base.transform_filter(
            alt.FieldEqualPredicate(field='Type', equal='Prediction')
        ).mark_line(size=3, color='#FF4B4B') # Warna merah agar menonjol

        # Gabungkan scatter (data asli) dan line (prediksi SVR)
        chart = (scatter + line).properties(
            title=title
        ).interactive() # Tambahkan zoom dan pan
        
        return chart

    # Gunakan kolom untuk tata letak 2x2
    col1, col2 = st.columns(2)

    with col1:
        st.subheader("Kernel: Linear")
        chart_lin = create_svr_chart(df_plot_final, 'linear', 'SVR dengan Kernel Linear')
        st.altair_chart(chart_lin, use_container_width=True)

        st.subheader("Kernel: Polynomial (Poly)")
        chart_poly = create_svr_chart(df_plot_final, 'poly', 'SVR dengan Kernel Polynomial')
        st.altair_chart(chart_poly, use_container_width=True)

    with col2:
        st.subheader("Kernel: RBF (Radial Basis Function)")
        chart_rbf = create_svr_chart(df_plot_final, 'rbf', 'SVR dengan Kernel RBF')
        st.altair_chart(chart_rbf, use_container_width=True)

        st.subheader("Kernel: Sigmoid")
        chart_sig = create_svr_chart(df_plot_final, 'sigmoid', 'SVR dengan Kernel Sigmoid')
        st.altair_chart(chart_sig, use_container_width=True)


    # --- 5. Analisis Visual ---
    st.header("3. Analisis Visual")
    st.markdown("""
    **Analisis Visual:**
    * **Kernel Linear** (garis lurus) menunjukkan garis regresi yang paling sederhana dan seringkali paling mudah diinterpretasi. Dalam kasus ini, R2-nya mungkin yang tertinggi, menunjukkan model ini paling cocok.
    * **Kernel Polynomial** mencoba mencocokkan data dengan kurva polinomial. Terkadang ini bisa *overfitting* jika derajatnya terlalu tinggi.
    * **Kernel RBF** sangat fleksibel dan dapat menangkap pola non-linear yang kompleks. Namun, pada data ini, ia mungkin menghasilkan kurva yang kurang intuitif.
    * **Kernel Sigmoid** seringkali menghasilkan bentuk kurva 'S' dan biasanya lebih cocok untuk tugas klasifikasi biner daripada regresi.
    
    Berdasarkan perbandingan, kita dapat melihat kernel mana yang secara visual dan metrik paling baik dalam memodelkan hubungan antara *Profit* dan *Sales* dalam data sampel ini.
    """)
else:
    st.warning("Data tidak dapat dimuat. Analisis tidak dapat dilanjutkan.")
