# -*- coding: utf-8 -*-
"""streamlitsvr.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zDg5UMjK1af5nQYwWkTQI_9i7OItWawr
"""

import streamlit as st
import pandas as pd
import numpy as np
import altair as alt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, r2_score

st.set_page_config(layout="wide")
st.title("ðŸš€ Analisis Support Vector Regression (SVR) pada Data Penjualan")

# --- 1. Fungsi Pembantu dan Pemrosesan Data ---

# Fungsi kustom untuk menghitung MAPE
def mean_absolute_percentage_error(y_true, y_pred):
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    # Hindari pembagian dengan nol jika y_true ada yang 0
    y_true[y_true == 0] = 1e-6
    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

# Cache data agar proses ini hanya berjalan sekali
@st.cache_data
def load_and_process_data():
    # Pastikan file CSV ada di root directory repository Streamlit Cloud Anda
    try:
        df = pd.read_csv('SuperStore_Sales_Dataset.csv')
        # Mengganti nama kolom yang mungkin bermasalah
        df = df.rename(columns={'Row ID+O6G3A1:R6': 'Row ID'})
    except FileNotFoundError:
        st.error("File 'SuperStore_Sales_Dataset.csv' tidak ditemukan. Pastikan file tersebut ada di repository Anda.")
        return None
    except Exception as e:
        st.error(f"Error saat membaca CSV: {e}")
        return None
        
    # Filter data berdasarkan kategori dan sub-kategori
    df_tech = df[df['Category'] == 'Technology']
    df_com = df_tech[df_tech['Sub-Category'] != 'Phones']
    
    # Tampilkan data yang difilter di luar fungsi cache (lihat di Main Execution)
    
    df_clean = df_com[['Sales', 'Profit', 'Quantity']].dropna().copy()
    
    # Filter data ekstrem
    df_clean = df_clean[
        (df_clean['Sales'] < 3000) &
        (df_clean['Sales'] > 0) &
        (df_clean['Profit'] > -500) &
        (df_clean['Profit'] < 800)
    ]
    
    # **PERBAIKAN ERROR 1: Sampling yang Aman (Robust Sampling)**
    n_samples = 400
    if len(df_clean) == 0:
        st.warning("Tidak ada data yang tersisa setelah filter. Coba ubah filter Anda.")
        return None
    
    # Jika data yang tersedia lebih sedikit dari n_samples, ambil semua data
    if len(df_clean) < n_samples:
        n_samples = len(df_clean)
        st.info(f"Hanya {n_samples} baris data yang tersedia setelah filter, mengambil semua.")
    
    # Mengambil subset untuk efisiensi komputasi SVR
    return df_clean.sample(n=n_samples, random_state=42), df_com

@st.cache_data
def run_svr_analysis(df_clean):
    if df_clean is None:
        return pd.DataFrame(), pd.DataFrame()
    
    # Tambahkan pengecekan jika data terlalu sedikit untuk di-split
    if len(df_clean) < 10:
        st.warning("Data terlalu sedikit untuk analisis SVR setelah sampling.")
        return pd.DataFrame(), pd.DataFrame()

    X = df_clean['Profit'].values.reshape(-1, 1)
    Y = df_clean['Sales'].values.reshape(-1, 1)

    # Pastikan test_size tidak lebih besar dari jumlah data
    test_split_size = 0.3
    if len(df_clean) * test_split_size < 1:
        test_split_size = 0.1 # Kurangi jika data sangat sedikit
        
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=test_split_size, random_state=42)
    
    # Jika test set kosong (karena data sangat sedikit), sulit dilanjutkan
    if len(X_test) == 0:
        st.warning("Gagal membuat test set, data terlalu sedikit.")
        return pd.DataFrame(), pd.DataFrame()

    scaler_X = StandardScaler()
    scaler_Y = StandardScaler()
    X_train_scaled = scaler_X.fit_transform(X_train)
    X_test_scaled = scaler_X.transform(X_test)
    Y_train_scaled = scaler_Y.fit_transform(Y_train).ravel()

    kernels = ['linear', 'poly', 'rbf', 'sigmoid']
    model_results = []
    
    X_range_scaled = np.linspace(X_train_scaled.min(), X_train_scaled.max(), 50).reshape(-1, 1)
    
    plot_data_list = []

    # Buat DataFrame dari test set
    df_test_sample = pd.DataFrame({'Profit': X_test.ravel(), 'Sales': Y_test.ravel()})
    
    # **PERBAIKAN ERROR 2: Sampling Plot yang Aman**
    n_plot_samples = 50
    if len(df_test_sample) < n_plot_samples:
        n_plot_samples = len(df_test_sample) # Ambil semua test points jika < 50
        
    df_test_sample = df_test_sample.sample(n=n_plot_samples, random_state=42).copy()
    df_test_sample['Type'] = 'Actual'
    
    for kernel in kernels:
        if kernel == 'linear':
            svr = SVR(kernel=kernel, C=10)
        elif kernel == 'poly':
            svr = SVR(kernel=kernel, C=50, degree=2, gamma='auto')
        elif kernel == 'rbf':
            svr = SVR(kernel=kernel, C=50, gamma='auto')
        elif kernel == 'sigmoid':
            # --- PENYESUAIAN PENTING UNTUK SIGMOID (dijaga dari perbaikan sebelumnya) ---
            svr = SVR(kernel=kernel, C=1, gamma=0.01, coef0=0)
            
        svr.fit(X_train_scaled, Y_train_scaled)
        
        # Evaluasi Metrik
        Y_pred_test_scaled = svr.predict(X_test_scaled)
        Y_pred_test = scaler_Y.inverse_transform(Y_pred_test_scaled.reshape(-1, 1))
        mse = mean_squared_error(Y_test, Y_pred_test)
        r2 = r2_score(Y_test, Y_pred_test)
        mape = mean_absolute_percentage_error(Y_test, Y_pred_test)
        model_results.append({'Kernel': kernel, 'MSE': mse, 'R2': r2, 'MAPE': mape})

        # Prediksi untuk plotting hyperplane (GARIS)
        Y_pred_range_scaled = svr.predict(X_range_scaled)
        Y_pred_range = scaler_Y.inverse_transform(Y_pred_range_scaled.reshape(-1, 1))

        # Buat DataFrame Prediksi
        df_pred = pd.DataFrame({
            'Profit': scaler_X.inverse_transform(X_range_scaled).ravel(),
            'Sales': Y_pred_range.ravel(),
            'Kernel': kernel,
            'Type': 'Prediction'
        })
        
        # Gabungkan data aktual (sample) dan prediksi (garis)
        df_actual_temp = df_test_sample.copy()
        df_actual_temp['Kernel'] = kernel
        
        plot_data_list.append(df_actual_temp)
        plot_data_list.append(df_pred)

    df_metrics = pd.DataFrame(model_results)
    df_plot_final = pd.concat(plot_data_list, ignore_index=True)

    return df_metrics, df_plot_final

# --- 2. Main Streamlit Execution ---
data_tuple = load_and_process_data()
df_clean = None
df_raw_filtered = None

if data_tuple is not None:
    df_clean, df_raw_filtered = data_tuple

# **PERBAIKAN ERROR 3: Pindahkan st.write ke sini**
if df_raw_filtered is not None:
    with st.expander("Lihat Data Mentah Setelah Filter (Kategori: Technology, Sub-Kategori: Bukan Phones)"):
        st.write(df_raw_filtered)

# Hanya jalankan jika data berhasil di-load dan diproses
if df_clean is not None:
    df_metrics, df_plot_final = run_svr_analysis(df_clean)

    # --- 3. Menampilkan Metrik Evaluasi ---
    if not df_metrics.empty:
        st.header("1. Metrik Evaluasi Model")
        df_metrics['MSE'] = df_metrics['MSE'].round(2)
        df_metrics['R2'] = df_metrics['R2'].round(4)
        df_metrics['MAPE'] = df_metrics['MAPE'].round(2).astype(str) + ' %'
        st.table(df_metrics.sort_values(by='R2', ascending=False))
    else:
        st.warning("Gagal menghitung metrik model.")

    # --- 4. Menampilkan Grafik Hyperplane (Altair) ---
    if not df_plot_final.empty:
        st.header("2. Visualisasi Hyperplane Regresi (Terpisah)")

        # Fungsi helper untuk membuat chart individual
        def create_svr_chart(df_data, kernel_name, title):
            df_kernel = df_data[df_data['Kernel'] == kernel_name].copy()
            if df_kernel.empty:
                return None # Kembalikan None jika tidak ada data untuk kernel ini

            base = alt.Chart(df_kernel).encode(
                x=alt.X('Profit', title='Keuntungan (Profit)', scale=alt.Scale(zero=False)),
                y=alt.Y('Sales', title='Penjualan (Sales)', scale=alt.Scale(zero=False)),
                tooltip=['Profit', 'Sales']
            )
            scatter = base.transform_filter(
                alt.FieldEqualPredicate(field='Type', equal='Actual')
            ).mark_point(opacity=0.6, size=30, color='gray', filled=True)
            line = base.transform_filter(
                alt.FieldEqualPredicate(field='Type', equal='Prediction')
            ).mark_line(size=3, color='#FF4B4B')
            chart = (scatter + line).properties(
                title=title
            ).interactive()
            return chart

        # Gunakan kolom untuk tata letak 2x2
        col1, col2 = st.columns(2)

        with col1:
            st.subheader("Kernel: Linear")
            chart_lin = create_svr_chart(df_plot_final, 'linear', 'SVR dengan Kernel Linear')
            if chart_lin: st.altair_chart(chart_lin, use_container_width=True)

            st.subheader("Kernel: Polynomial (Poly)")
            chart_poly = create_svr_chart(df_plot_final, 'poly', 'SVR dengan Kernel Polynomial')
            if chart_poly: st.altair_chart(chart_poly, use_container_width=True)

        with col2:
            st.subheader("Kernel: RBF (Radial Basis Function)")
            chart_rbf = create_svr_chart(df_plot_final, 'rbf', 'SVR dengan Kernel RBF')
            if chart_rbf: st.altair_chart(chart_rbf, use_container_width=True)

            st.subheader("Kernel: Sigmoid")
            chart_sig = create_svr_chart(df_plot_final, 'sigmoid', 'SVR dengan Kernel Sigmoid')
            if chart_sig: st.altair_chart(chart_sig, use_container_width=True)

        # --- 5. Analisis Visual ---
        st.header("3. Analisis Visual")
        st.markdown("""
        **Analisis Visual:**
        * **Kernel Linear** (garis lurus) menunjukkan garis regresi yang paling sederhana dan seringkali paling mudah diinterpretasi.
        * **Kernel Polynomial** mencoba mencocokkan data dengan kurva polinomial.
        * **Kernel RBF** sangat fleksibel dan dapat menangkap pola non-linear yang kompleks.
        * **Kernel Sigmoid** (dengan parameter yang disesuaikan) seharusnya sekarang menunjukkan kurva yang lebih stabil, meskipun mungkin masih bukan yang terbaik untuk data ini.
        
        Bandingkan metrik (terutama R2) dengan visual untuk menentukan model terbaik.
        """)
    else:
        st.warning("Gagal membuat data plot.")
else:
    st.error("Gagal memuat atau memproses data. Analisis dihentikan.")
