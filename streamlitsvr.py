# -*- coding: utf-8 -*-
"""streamlitsvr.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zDg5UMjK1af5nQYwWkTQI_9i7OItWawr
"""

import streamlit as st
import pandas as pd
import numpy as np
import altair as alt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, r2_score

st.set_page_config(layout="wide")
st.title("ðŸš€ Analisis Support Vector Regression (SVR) pada Data Penjualan")

# --- 1. Fungsi Pembantu dan Pemrosesan Data ---

# Fungsi kustom untuk menghitung MAPE
def mean_absolute_percentage_error(y_true, y_pred):
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    # Handle division by zero/near zero by replacing y_true=0 with a tiny value
    y_true[y_true == 0] = 1e-6 
    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

@st.cache_data
def load_and_process_data():
    # Memuat data dari file SuperStore_Sales_Dataset.csv
    # Diasumsikan file diunggah atau berada di path yang sama
    df = pd.read_csv("SuperStore_Sales_Dataset.csv", sep=",", na_values="#N/A")

    # Pembersihan dan Filter Data
    df_clean = df[['Sales', 'Profit', 'Quantity']].dropna().copy()
    
    # Filter out data extremes for better model stability and clearer visualization
    df_clean = df_clean[(df_clean['Sales'] < 3000) & 
                        (df_clean['Sales'] > 0) & 
                        (df_clean['Profit'] > -500) & 
                        (df_clean['Profit'] < 800)]
    
    # Mengambil subset 1000 data acak untuk visualisasi cepat
    df_clean = df_clean.sample(n=1000, random_state=42)

    return df_clean

@st.cache_data
def run_svr_analysis(df_clean):
    # Definisikan X (Profit) dan Y (Sales)
    X = df_clean['Profit'].values.reshape(-1, 1)
    Y = df_clean['Sales'].values.reshape(-1, 1)

    # Membagi dan Scaling Data
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.3, random_state=42)
    scaler_X = StandardScaler()
    scaler_Y = StandardScaler()
    X_train_scaled = scaler_X.fit_transform(X_train)
    X_test_scaled = scaler_X.transform(X_test)
    Y_train_scaled = scaler_Y.fit_transform(Y_train).ravel()

    kernels = ['linear', 'poly', 'rbf', 'sigmoid']
    model_results = []
    prediction_data = []

    # Membuat range Profit untuk plot hyperplane
    X_range_scaled = np.linspace(X_train_scaled.min(), X_train_scaled.max(), 100).reshape(-1, 1)

    for kernel in kernels:
        # Melatih Model SVR
        svr = SVR(kernel=kernel, C=100, gamma='auto') 
        svr.fit(X_train_scaled, Y_train_scaled)
        
        # Prediksi pada set pengujian
        Y_pred_test_scaled = svr.predict(X_test_scaled)
        Y_pred_test = scaler_Y.inverse_transform(Y_pred_test_scaled.reshape(-1, 1))
        
        # Prediksi untuk plotting hyperplane
        Y_pred_range_scaled = svr.predict(X_range_scaled)
        Y_pred_range = scaler_Y.inverse_transform(Y_pred_range_scaled.reshape(-1, 1))

        # Evaluasi Metrik
        mse = mean_squared_error(Y_test, Y_pred_test)
        r2 = r2_score(Y_test, Y_pred_test)
        mape = mean_absolute_percentage_error(Y_test, Y_pred_test)
        
        model_results.append({'Kernel': kernel, 'MSE': mse, 'R2': r2, 'MAPE': mape})
        
        # Data untuk Altair
        plot_df = pd.DataFrame({
            'Profit': scaler_X.inverse_transform(X_range_scaled).ravel(),
            'Sales_Prediction': Y_pred_range.ravel(),
            'Kernel': kernel
        })
        prediction_data.append(plot_df)

    df_metrics = pd.DataFrame(model_results)
    df_predictions = pd.concat(prediction_data)
    df_test = pd.DataFrame({'Profit': X_test.ravel(), 'Sales_Actual': Y_test.ravel()})

    return df_metrics, df_predictions, df_test

# --- 2. Main Streamlit Execution ---
df_clean = load_and_process_data()
df_metrics, df_predictions, df_test = run_svr_analysis(df_clean)

# --- 3. Menampilkan Metrik Evaluasi ---
st.header("1. Metrik Evaluasi Model")

# Formatting metrik
df_metrics['MSE'] = df_metrics['MSE'].round(2)
df_metrics['R2'] = df_metrics['R2'].round(4)
df_metrics['MAPE'] = df_metrics['MAPE'].round(2).astype(str) + ' %'

st.table(df_metrics.sort_values(by='R2', ascending=False))

st.markdown("""
**Ringkasan Prediksi Laris/Tidak Laris (Berdasarkan Model Regresi):**
SVR memprediksi nilai *Sales* secara kontinu. Untuk menginterpretasikan sebagai "laris atau tidak laris", kita dapat melihat bahwa:
* Model kernel **linear** memiliki nilai **RÂ² tertinggi (terbaik)** dan **MAPE terendah**, menunjukkan prediksi *Sales* yang paling akurat dalam rentang data yang diuji.
* Kernel lain menghasilkan **RÂ² negatif**, yang berarti model SVR tersebut **lebih buruk** daripada hanya memprediksi nilai rata-rata *Sales*.
""")

# --- 4. Menampilkan Grafik Hyperplane (Altair) ---
st.header("2. Visualisasi Hyperplane Regresi (Altair)")

# Scatter plot untuk data aktual (Test Set)
scatter = alt.Chart(df_test).mark_point(opacity=0.5, size=20, color='gray').encode(
    x=alt.X('Profit', title='Keuntungan (Profit)'),
    y=alt.Y('Sales_Actual', title='Penjualan Aktual (Sales)'),
    tooltip=['Profit', 'Sales_Actual']
)

# Line chart untuk prediksi SVR (Hyperplane)
line = alt.Chart(df_predictions).mark_line(size=3).encode(
    x=alt.X('Profit'),
    y=alt.Y('Sales_Prediction'),
    color=alt.Color('Kernel', title='Kernel SVR'),
    tooltip=['Kernel', 'Profit', 'Sales_Prediction']
)

# Menggabungkan dan Facet (memecah grafik berdasarkan kernel)
chart = (scatter + line).facet(
    column=alt.Column('Kernel', header=alt.Header(titleOrient="bottom", labelOrient="bottom")),
    columns=2
).resolve_scale(
    y='independent',  # Y-axis independen untuk melihat bentuk fit lebih jelas
    x='independent'
).properties(
    title="Perbandingan Hyperplane SVR Berdasarkan Kernel (Sales vs. Profit)"
).interactive() # Memungkinkan zoom dan pan

st.altair_chart(chart, use_container_width=True)

st.markdown("""
**Analisis Visual:**
* **Garis Hyperplane** yang terbentuk menunjukkan bagaimana masing-masing kernel mencoba memodelkan hubungan antara Keuntungan dan Penjualan.
* **Kernel Linear** (garis lurus) menunjukkan garis regresi yang paling masuk akal, yang konsisten dengan metrik evaluasi yang menyatakan kernel ini paling baik memprediksi *Sales* di dataset ini.
* **Kernel Non-Linear** (*rbf*, *poly*, *sigmoid*) menghasilkan kurva yang aneh karena data penjualan dan keuntungan seringkali tidak memiliki hubungan non-linear yang kompleks dan terstruktur seperti yang diasumsikan kernel-kernel tersebut.
""")
