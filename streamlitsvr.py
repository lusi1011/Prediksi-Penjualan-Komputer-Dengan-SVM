# -*- coding: utf-8 -*-
"""streamlitsvr.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zDg5UMjK1af5nQYwWkTQI_9i7OItWawr
"""

import streamlit as st
import pandas as pd
import numpy as np
import altair as alt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, r2_score

# Konfigurasi Halaman
st.set_page_config(layout="wide", page_title="SVR Sales Analysis")
st.title("Analisis Support Vector Regression (SVR)")
st.caption("Memprediksi Jumlah (Quantity) berdasarkan Penjualan (Sales) pada data Teknologi (Non-Phones).")

# --- 1. Fungsi Pembantu dan Pemrosesan Data ---

# Fungsi kustom untuk menghitung MAPE
def mean_absolute_percentage_error(y_true, y_pred):
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    # Hindari pembagian dengan nol jika y_true ada yang 0
    y_true[y_true == 0] = 1e-6
    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

# Cache data agar proses ini hanya berjalan sekali
@st.cache_data
def load_and_process_data():
    try:
        # Ganti dengan path file CSV Anda
        df = pd.read_csv('SuperStore_Sales_Dataset.csv')
        # Mengganti nama kolom yang mungkin bermasalah (dipertahankan dari kode asli)
        df = df.rename(columns={'Row ID+O6G3A1:R6': 'Row ID'})
    except FileNotFoundError:
        st.error("File 'SuperStore_Sales_Dataset.csv' tidak ditemukan. Analisis dibatalkan.")
        return None, None
    except Exception as e:
        st.error(f"Error saat membaca CSV: {e}")
        return None, None
        
    # Filter data berdasarkan kategori dan sub-kategori
    df_tech = df[df['Category'] == 'Technology']
    df_com = df_tech[df_tech['Sub-Category'] != 'Phones']
        
    df_clean = df_com[['Sales', 'Profit', 'Quantity']].dropna().copy()
    
    # Filter data ekstrem
    df_clean = df_clean[
        (df_clean['Sales'] < 3000) &
        (df_clean['Sales'] > 0) &
        (df_clean['Profit'] > -500) &
        (df_clean['Profit'] < 800)
    ]
    
    # Sampling yang Aman
    n_samples = 250
    if len(df_clean) == 0:
        st.warning("Tidak ada data yang tersisa setelah filter. Coba ubah filter Anda.")
        return None, None
        
    if len(df_clean) < n_samples:
        n_samples = len(df_clean)
        
    # Mengambil subset untuk efisiensi komputasi SVR
    return df_clean.sample(n=n_samples, random_state=42), df_com

@st.cache_data(show_spinner="Menjalankan SVR untuk semua kernel...")
def run_all_svr_analysis(df_clean):
    """Menjalankan SVR untuk semua kernel default untuk mendapatkan metrik."""
    if df_clean is None or len(df_clean) < 10:
        return pd.DataFrame(), pd.DataFrame()

    X = df_clean['Sales'].values.reshape(-1, 1)
    Y = df_clean['Quantity'].values.reshape(-1, 1)

    # Pastikan test_size tidak lebih besar dari jumlah data
    test_split_size = 0.3
    if len(df_clean) * test_split_size < 1:
        test_split_size = 0.1 
            
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=test_split_size, random_state=42)
    
    if len(X_test) == 0:
        return pd.DataFrame(), pd.DataFrame()

    scaler_X = StandardScaler()
    scaler_Y = StandardScaler()
    X_train_scaled = scaler_X.fit_transform(X_train)
    X_test_scaled = scaler_X.transform(X_test)
    Y_train_scaled = scaler_Y.fit_transform(Y_train).ravel()

    kernels = ['linear', 'poly', 'rbf', 'sigmoid']
    model_results = []
    
    X_range_scaled = np.linspace(X_train_scaled.min(), X_train_scaled.max(), 50).reshape(-1, 1)
    plot_data_list = []
    
    n_plot_samples = 50
    df_test_actual = pd.DataFrame({'Sales': X_test.ravel(), 'Quantity': Y_test.ravel()}) # Fix: X=Sales, Y=Quantity
    if len(df_test_actual) > n_plot_samples:
        df_test_actual = df_test_actual.sample(n=n_plot_samples, random_state=42)
    df_test_actual['Type'] = 'Actual'
    
    for kernel in kernels:
        # Konfigurasi parameter default
        if kernel == 'linear':
            svr = SVR(kernel=kernel, C=10)
        elif kernel == 'poly':
            svr = SVR(kernel=kernel, C=50, degree=2, gamma='auto')
        elif kernel == 'rbf':
            svr = SVR(kernel=kernel, C=50, gamma='auto')
        elif kernel == 'sigmoid':
            svr = SVR(kernel=kernel, C=1, gamma=0.1, coef0=0)
            
        svr.fit(X_train_scaled, Y_train_scaled)
        
        # Evaluasi Metrik
        Y_pred_test_scaled = svr.predict(X_test_scaled)
        Y_pred_test = scaler_Y.inverse_transform(Y_pred_test_scaled.reshape(-1, 1))
        
        mse = mean_squared_error(Y_test, Y_pred_test)
        r2 = r2_score(Y_test, Y_pred_test)
        mape = mean_absolute_percentage_error(Y_test, Y_pred_test)
        model_results.append({'Kernel': kernel, 'MSE': mse, 'R2': r2, 'MAPE': mape})

        # Prediksi untuk plotting hyperplane (GARIS)
        Y_pred_range_scaled = svr.predict(X_range_scaled)
        Y_pred_range = scaler_Y.inverse_transform(Y_pred_range_scaled.reshape(-1, 1))

        # Buat DataFrame Prediksi (Garis Regresi)
        df_pred = pd.DataFrame({
            'Sales': scaler_X.inverse_transform(X_range_scaled).ravel(), # Fix: X-axis is Sales
            'Quantity': Y_pred_range.ravel(),                            # Fix: Y-axis is Quantity
            'Kernel': kernel,
            'Type': 'Prediction'
        })
        
        # Gabungkan data aktual (sample) dan prediksi (garis) untuk plot individual
        df_actual_temp = df_test_actual.copy()
        df_actual_temp['Kernel'] = kernel
        
        plot_data_list.append(df_actual_temp)
        plot_data_list.append(df_pred)

    df_metrics = pd.DataFrame(model_results)
    df_plot_final = pd.concat(plot_data_list, ignore_index=True)

    return df_metrics, df_plot_final, scaler_X, scaler_Y, X_train_scaled, Y_train_scaled, X_train

def create_svr_chart(df_data, kernel_name, title):
    """Fungsi helper untuk membuat chart Altair individual."""
    df_kernel = df_data[df_data['Kernel'] == kernel_name].copy()
    if df_kernel.empty:
        return None 

    base = alt.Chart(df_kernel).encode(
        x=alt.X('Sales', title='Penjualan (Sales)', scale=alt.Scale(zero=False)),
        y=alt.Y('Quantity', title='Jumlah (Quantity)', scale=alt.Scale(zero=False)),
        tooltip=['Sales', 'Quantity']
    )
    
    # Titik Data Aktual
    scatter = base.transform_filter(
        alt.FieldEqualPredicate(field='Type', equal='Actual')
    ).mark_point(opacity=0.6, size=50, color='gray', filled=True)
    
    # Garis Prediksi (Hyperplane)
    line = base.transform_filter(
        alt.FieldEqualPredicate(field='Type', equal='Prediction')
    ).mark_line(size=3, color='#FF4B4B')
    
    chart = (scatter + line).properties(
        title=title
    ).interactive()
    return chart

# --- 2. Main Streamlit Execution ---
df_clean, df_raw_filtered = load_and_process_data()

# Tampilkan Data Mentah
if df_raw_filtered is not None:
    with st.expander("Lihat Data Mentah Setelah Filter (Kategori: Technology, Sub-Kategori: Bukan Phones)"):
        st.write(df_raw_filtered)

# Hanya jalankan jika data berhasil di-load dan diproses
if df_clean is not None and len(df_clean) >= 10:
    df_metrics, df_plot_final, scaler_X, scaler_Y, X_train_scaled, Y_train_scaled, X_train = run_all_svr_analysis(df_clean)

    # --- 3. Menampilkan Metrik Evaluasi ---
    st.header("1. Perbandingan Metrik Default Semua Model")
    if not df_metrics.empty:
        # Format Metrik
        df_metrics['MSE'] = df_metrics['MSE'].round(2)
        df_metrics['R2'] = df_metrics['R2'].round(4)
        df_metrics['MAPE'] = df_metrics['MAPE'].round(2).astype(str) + ' %'
        st.dataframe(df_metrics.sort_values(by='R2', ascending=False), use_container_width=True)
    else:
        st.warning("Gagal menghitung metrik model. Pastikan ada cukup data (minimal 10 baris).")

    # --- 4. Visualisasi Hyperplane (Semua Kernel Default) ---
    st.header("2. Visualisasi Hyperplane Regresi (Default Parameters)")
    if not df_plot_final.empty:
        col1, col2 = st.columns(2)

        kernels = ['linear', 'poly', 'rbf', 'sigmoid']
        titles = ['Linear', 'Polynomial', 'RBF (Radial Basis Function)', 'Sigmoid']
        
        for i, (kernel, title) in enumerate(zip(kernels, titles)):
            chart = create_svr_chart(df_plot_final, kernel, f'SVR dengan Kernel {title}')
            if chart:
                target_col = col1 if i % 2 == 0 else col2
                with target_col:
                    st.subheader(f"Kernel: {title}")
                    st.altair_chart(chart, use_container_width=True)

    # --- 5. Interaktivitas: Custom Kernel ---
    st.header("3. Interaktif: Uji Coba Kernel dan Tuning Parameter")
    
    st.sidebar.header("Tuning Parameter SVR")
    selected_kernel = st.sidebar.selectbox("Pilih Kernel", ['rbf', 'linear', 'poly', 'sigmoid'], index=0)
    
    # Batas C disesuaikan karena SVR sensitif terhadap skalanya
    c_value = st.sidebar.slider("Pilih nilai C (Regularisasi)", 0.1, 100.0, 50.0) 
    
    gamma_value = 'auto'
    if selected_kernel in ['rbf', 'poly', 'sigmoid']:
        gamma_value = st.sidebar.slider("Pilih nilai Gamma", 0.001, 10.0, 0.1)

    # Run SVR for the selected kernel
    @st.cache_data(show_spinner=f"Menghitung SVR dengan kernel {selected_kernel}...")
    def run_custom_svr(df_clean, kernel, C, gamma):
        X = df_clean['Sales'].values.reshape(-1, 1)
        Y = df_clean['Quantity'].values.reshape(-1, 1)

        scaler_X = StandardScaler()
        scaler_Y = StandardScaler()
        X_scaled = scaler_X.fit_transform(X)
        Y_scaled = scaler_Y.fit_transform(Y).ravel()
        
        # Konfigurasi SVR
        if kernel == 'poly':
            degree = st.sidebar.slider("Pilih Degree (untuk Poly)", 1, 5, 2)
            svr = SVR(kernel=kernel, C=C, degree=degree, gamma=gamma)
        elif kernel == 'sigmoid':
            coef0 = st.sidebar.slider("Pilih Coef0 (untuk Sigmoid)", -10.0, 10.0, 0.0)
            svr = SVR(kernel=kernel, C=C, gamma=gamma, coef0=coef0)
        else:
            svr = SVR(kernel=kernel, C=C, gamma=gamma)
            
        svr.fit(X_scaled, Y_scaled)
        
        # Membuat range untuk plotting (menggunakan seluruh range data bersih)
        X_range_scaled = np.linspace(X_scaled.min(), X_scaled.max(), 100).reshape(-1, 1)
        Y_pred_range_scaled = svr.predict(X_range_scaled)
        Y_pred_range = scaler_Y.inverse_transform(Y_pred_range_scaled.reshape(-1, 1))

        # Data Plot Prediksi (Garis)
        df_pred_custom = pd.DataFrame({
            'Sales': scaler_X.inverse_transform(X_range_scaled).ravel(),
            'Quantity': Y_pred_range.ravel(),
            'Kernel': kernel,
            'Type': 'Prediction'
        })
        
        # Data Plot Aktual (Titik)
        df_actual_custom = pd.DataFrame({'Sales': X.ravel(), 'Quantity': Y.ravel()})
        df_actual_custom['Kernel'] = kernel
        df_actual_custom['Type'] = 'Actual'
        
        df_plot_custom = pd.concat([df_actual_custom, df_pred_custom], ignore_index=True)

        return df_plot_custom
    
    df_plot_custom = run_custom_svr(df_clean, selected_kernel, c_value, gamma_value)
    
    # Buat chart custom
    custom_chart = create_svr_chart(
        df_plot_custom, 
        selected_kernel, 
        f'SVR Kustom: Kernel {selected_kernel.capitalize()}, C={c_value:.1f}, Gamma={gamma_value}'
    )
    if custom_chart: st.altair_chart(custom_chart, use_container_width=True)

    st.markdown("""
    ---
    **Catatan Analisis:**
    * **C (Regularisasi):** Nilai `C` yang lebih besar berarti kesalahan *margin* (titik data di luar hyperplane) akan dikenakan penalti yang lebih besar. Ini menghasilkan model yang lebih kompleks (kurva yang lebih ketat).
    * **Gamma:** Kontrol seberapa jauh pengaruh satu titik data pelatihan. Nilai `gamma` yang lebih tinggi akan menghasilkan model yang sangat sensitif (overfitting).
    * **Metrik R2** menunjukkan seberapa baik model menjelaskan variabilitas data (semakin mendekati 1, semakin baik).
    """)

else:
    if df_clean is not None:
        st.error(f"Data tersisa ({len(df_clean)} baris) terlalu sedikit untuk analisis SVR (minimal 10 baris diperlukan).")
