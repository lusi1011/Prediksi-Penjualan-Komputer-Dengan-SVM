# -*- coding: utf-8 -*-
"""streamlit

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1shO92uUQrrLOIZ5jRJSjmyTY4Ah8rROx
"""

import streamlit as st
import pandas as pd
import numpy as np
import altair as alt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, r2_score

st.set_page_config(layout="wide")
st.title("ðŸš€ Analisis Support Vector Regression (SVR) pada Data Penjualan")

# --- 1. Fungsi Pembantu dan Pemrosesan Data ---

# Fungsi kustom untuk menghitung MAPE
def mean_absolute_percentage_error(y_true, y_pred):
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    y_true[y_true == 0] = 1e-6
    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

# Cache data agar proses ini hanya berjalan sekali
@st.cache_data
def run_svr_analysis(df_clean):
    if df_clean is None:
        return pd.DataFrame(), pd.DataFrame()
    
    if len(df_clean) < 10:
        st.warning("Data terlalu sedikit untuk analisis SVR setelah sampling.")
        return pd.DataFrame(), pd.DataFrame()

    # --- FITUR TAMBAHAN: Profit^2 untuk memperkuat non-linearitas ---
    st.info("Menggunakan fitur: Profit, Profit^2, dan Quantity untuk memprediksi Sales.")
    df_clean = df_clean.copy()
    df_clean['Profit2'] = df_clean['Profit'] ** 2

    X = df_clean[['Profit', 'Profit2', 'Quantity']].values
    Y = df_clean['Sales'].values

    # --- Split data ---
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.25, random_state=42)

    # --- Gunakan RobustScaler agar tahan outlier ---
    from sklearn.preprocessing import RobustScaler
    scaler_X = RobustScaler()
    scaler_Y = RobustScaler()

    X_train_scaled = scaler_X.fit_transform(X_train)
    X_test_scaled = scaler_X.transform(X_test)
    Y_train_scaled = scaler_Y.fit_transform(Y_train.reshape(-1, 1)).ravel()

    kernels = ['linear', 'poly', 'rbf', 'sigmoid']
    model_results = []
    plot_data_list = []

    # Rentang Profit untuk visualisasi
    profit_range_scaled = np.linspace(X_train_scaled[:, 0].min(), X_train_scaled[:, 0].max(), 60)
    profit2_range_scaled = profit_range_scaled ** 2
    quantity_mean_scaled = np.full(60, X_train_scaled[:, 2].mean())
    X_range_scaled = np.column_stack((profit_range_scaled, profit2_range_scaled, quantity_mean_scaled))

    df_test_sample = pd.DataFrame({
        'Profit': X_test[:, 0],
        'Quantity': X_test[:, 2],
        'Sales': Y_test.ravel(),
        'Type': 'Actual'
    }).sample(min(50, len(X_test)), random_state=42)

    # --- HYPERPARAMETER OPTIMISASI ---
    for kernel in kernels:
        if kernel == 'linear':
            svr = SVR(kernel=kernel, C=100, epsilon=0.05)
        elif kernel == 'poly':
            svr = SVR(kernel=kernel, C=150, degree=3, gamma=0.4, epsilon=0.05, coef0=1)
        elif kernel == 'rbf':
            svr = SVR(kernel=kernel, C=200, gamma=0.3, epsilon=0.03)
        elif kernel == 'sigmoid':
            svr = SVR(kernel=kernel, C=120, gamma=0.2, coef0=5, epsilon=0.05)

        svr.fit(X_train_scaled, Y_train_scaled)

        # Prediksi
        Y_pred_scaled = svr.predict(X_test_scaled)
        Y_pred = scaler_Y.inverse_transform(Y_pred_scaled.reshape(-1, 1))

        mse = mean_squared_error(Y_test, Y_pred)
        r2 = r2_score(Y_test, Y_pred)
        mape = mean_absolute_percentage_error(Y_test, Y_pred)

        model_results.append({'Kernel': kernel, 'MSE': mse, 'R2': r2, 'MAPE': mape})

        # --- Untuk plotting ---
        Y_pred_range_scaled = svr.predict(X_range_scaled)
        Y_pred_range = scaler_Y.inverse_transform(Y_pred_range_scaled.reshape(-1, 1))
        profit_range_unscaled = scaler_X.inverse_transform(np.column_stack((profit_range_scaled, profit2_range_scaled, quantity_mean_scaled)))[:, 0]

        df_pred = pd.DataFrame({
            'Profit': profit_range_unscaled,
            'Sales': Y_pred_range.ravel(),
            'Kernel': kernel,
            'Type': 'Prediction'
        })

        df_actual_temp = df_test_sample.copy()
        df_actual_temp['Kernel'] = kernel
        plot_data_list.append(df_actual_temp)
        plot_data_list.append(df_pred)

    df_metrics = pd.DataFrame(model_results)
    df_plot_final = pd.concat(plot_data_list, ignore_index=True)

    # --- PILIH MODEL TERBAIK ---
    best_model = df_metrics.sort_values(by='MAPE').iloc[0]
    if best_model['MAPE'] <= 19:
        st.success(f"ðŸŽ¯ Target tercapai! Kernel terbaik: **{best_model['Kernel']}**, MAPE: {best_model['MAPE']:.2f}%")
    else:
        st.warning(f"MAPE masih {best_model['MAPE']:.2f}%, coba sesuaikan filter data atau parameter SVR.")

    return df_metrics, df_plot_final
